import fs from 'fs'
import path from 'path'
import events from 'events'
import request from 'request'
import fetch from 'node-fetch'
import { loaderOn } from '../utils/loader.js'
import { spinnerOn } from '../utils/spinner.js'
import { Converter } from '../utils/converter.js'
import { formats, formatsConterter } from '../constants/formatsConterter.js'
import { stepperOn } from '../utils/stepper.js'

// TODO: —Ç–µ—Ä—è–µ—Ç—Å—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
// TODO: —Å–¥–µ–ª–∞—Ç—å –∏–º—è —Ñ–∞–π–ª–∞ –∫–∞–∫ message_id –∞ –Ω–µ file_27
// TODO: –æ–ø—Ç–∞–ª–µ–¥—è—Ç—å —Ç–∏–ø —Ñ–∞–π–ª–∞ –æ—Ç —Ç–∏–ø–∞ –≤ meta telegram

function getPagination(current, formatsArray, msgID) {
  var formats = []
  const formatPages = []

  for (let i = 0; formatsArray.length >= i; i = i + 4) {
    let level = []
    if (formatsArray[i])
      level.push({ text: formatsArray[i], callback_data: `${formatsArray[i]}-${msgID}` })
    if (formatsArray[i + 1])
      level.push({ text: formatsArray[i + 1], callback_data: `${formatsArray[i + 1]}-${msgID}` })
    if (formatsArray[i + 2])
      level.push({ text: formatsArray[i + 2], callback_data: `${formatsArray[i + 2]}-${msgID}` })
    if (formatsArray[i + 3])
      level.push({ text: formatsArray[i + 3], callback_data: `${formatsArray[i + 3]}-${msgID}` })
    formats.push(level)
  }

  for (let i = 0; formats.length >= i; i = i + 4) {
    if (formats[i])
      formatPages.push([formats[i], formats[i + 1], formats[i + 2], formats[i + 3]])
  }

  const keys = []
  if (current > 1) keys.push({ text: `¬´1`, callback_data: '1' })
  if (current > 2) keys.push({ text: `‚Äπ${current - 1}`, callback_data: (current - 1).toString() })
  keys.push({ text: `-${current}-`, callback_data: current.toString() })
  if (current < formatPages.length - 1) keys.push({ text: `${current + 1}‚Ä∫`, callback_data: (current + 1).toString() })
  if (current < formatPages.length) keys.push({
    text: `${formatPages.length}¬ª`,
    callback_data: formatPages.length.toString()
  })

  return {
    reply_markup: JSON.stringify({
      inline_keyboard: [...formatPages[current - 1], keys]
    })
  }
}

const download = (url, path, callback) => {
  request.head(url, (err, res, body) => {
    request(url).pipe(fs.createWriteStream(path)).on('close', callback)
  })
}

export const onMessageDocument = async (bot, msg) => {
  const converter = new Converter()
  // const formats = await converter.getSupportedConversionTypes()
  // –≤–∫–ª—é—á–∏—Ç—å –ª–æ–∞–¥–µ—Ä
  let spinner = await spinnerOn(bot, msg.chat.id, null, 'document')
  // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –Ω–∞ –º–æ–π —Å–µ—Ä–≤–µ—Ä
  const fileId = msg.document.file_id
  const fileType = msg.document['file_name'].split('.')
  const type = fileType[fileType.length - 1]
  console.log('type', type)
  let typesForConverter = formats.find(i => i.sourceFormat === type)

  if (!typesForConverter) {
    await bot.deleteMessage(msg.chat.id, spinner)
    await bot.sendMessage(msg.chat.id, '–î–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è')
    return true
  }

  // const x = typesForConverter.targetFormats.filter(i => formatsConterter.filter(x => i === x ? x : null))
  let result = typesForConverter.targetFormats.filter((arr) => formatsConterter.includes(arr))

  await bot.sendMessage(msg.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç, –≤ –∫–æ—Ç–æ—Ä—ã–π –≤—ã –±—ã —Ö–æ—Ç–µ–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª', {
    ...getPagination(1, result, msg.chat.id)
  }).then(() => bot.deleteMessage(msg.chat.id, spinner).catch())
    .catch(() => bot.deleteMessage(msg.chat.id, spinner).catch())

  const eventEmitter = new events.EventEmitter()

  for (let i = 0; result.length > i; i++) {
    console.log('${result[i]}${msg.chat.id}', `${result[i]}${msg.from.id}`)

    eventEmitter.on(`${result[i]}-${msg.from.id}`, async function(msg) {
      if (msg.data.includes(msg.from.id)) {
        await bot.deleteMessage(msg.from.id, msg.message.message_id).catch()
        const waiting = await stepperOn(bot, msg.from.id, 0)
        const resFile = await fetch(`https://api.telegram.org/bot${process.env.TELEGRAM_API_KEY}/getFile?file_id=${fileId}`)
        const res2 = await resFile.json()
        const filePath = res2.result.file_path
        const fileName = filePath.split('/')[1]
        const downloadURL = `https://api.telegram.org/file/bot${process.env.TELEGRAM_API_KEY}/${filePath}`
        download(downloadURL, path.join('conversions', fileName), async () => {
          console.log('üü©Done!', msg)
          bot.sendMessage(process.env.NOTIF_GROUP, `üîß ${msg.from.first_name} ${type} to ${msg.data.split('-')[0]}`).catch()
          await stepperOn(bot, msg.from.id, 1, waiting)
          // –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª –Ω–∞ —Å–µ—Ä–≤–µ—Ä —Å–µ—Ä–≤–∏—Å–∞

          await converter.getUpload(`conversions/${fileName}`).then(async res => {
            await stepperOn(bot, msg.from.id, 2, waiting)
            // –Ω–∞—á–∞—Ç—å –ø—Ä–æ—Ü–µ–¥—É—Ä—É –∫–æ–Ω—Ñ–µ—Ä—Ç–∞—Ü–∏–∏
          })

          const newFile = await converter.getConverter(
            `conversions/${fileName}`,
            msg.data.split('-')[0], // —Ñ–æ—Ä–º–∞—Ç –≤ –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
            bot,
            msg
          )

          if (newFile) {
            await stepperOn(bot, msg.from.id, 3, waiting)
            await converter.getDownload(newFile[0].path, newFile[0].name, msg.from.id, bot, waiting?.message_id)
          }
        })

        return true
      }
    })
  }

  bot.on('callback_query', function onCallbackQuery(callbackQuery) {
    eventEmitter.emit(callbackQuery.data, callbackQuery)
    bot.answerCallbackQuery(callbackQuery.id, 'on_message_document', false)

    if (!callbackQuery.data.includes(msg.from.id)) {
      const editOptions = Object.assign({}, getPagination(parseInt(callbackQuery.data), result, msg.from.id), {
        chat_id: msg.from.id,
        message_id: callbackQuery.message.message_id
      })
      bot.editMessageText('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç, –≤ –∫–æ—Ç–æ—Ä—ã–π –≤—ã –±—ã —Ö–æ—Ç–µ–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª', editOptions)
    }
  })

  // await bot.deleteMessage(msg.chat.id, waiting)
  return true
}